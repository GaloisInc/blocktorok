config {
    timeDomain: transient; -- steady state or transient simulation
    timeStep : 5e-3 s; -- size of the time step
	timeIterations : 200; -- total number of time steps
	-- I'm making the assumption that all backends utilize the loosely coupled approach:
	-- time -> outer iter where coupling/information exchange happens -> inner iter for each zone/model convergence
	couplingIterations: 1000;

    const Tw = LIB_PhysicsParametersSolid.SOLID_TEMPERATURE_INIT;
    run: coupleModels1 (Tw);
    
    backend : Su2 {
        format : LIB_InputOutput,
        -- other options regarding settings for both models:
        -- 1. use with statement in run: coupleModels1 (Tw) with {LIB_SharedSettings}
        -- 2. parameters in LIB_SharedSettings can go in LIB_InputOutput (rename LIB_InputOutput to something like LIB_SharedSettings)
        sharedParams: LIB_SharedSettings
        gridDeform: LIB_GridDeformation
      };
}

model SolidModel (qw) {
  technique : FVM;
  innerIterations: 100;
  mesh: vehicle-axi-filled.su2;
  boundaryField : MARKER_SYM= ( Symmetry );
  physics : LIB_PhysicsParametersSolid.SOLVER; -- this line serves no purpose
  const rhos = LIB_PhysicsParametersSolid.SOLID_DENSITY;
  const ks = LIB_PhysicsParametersSolid.SOLID_THERMAL_CONDUCTIVITY;
  const cps = LIB_PhysicsParametersSolid.SPECIFIC_HEAT_CP;
  var Tw;
  rhos*cps*∇Tw- ks*△Tw = qw;
  solve Tw with {LIB_PhysicsParametersSolid, LIB_SolvingTechniqueSolid, LIB_NumericalSchemeSolid};
  return Tw;
  }

model FluidModel (Temp) {
    technique : FVM;
    innerIterations: 10000;
    mesh: fore-aft-no-sting-axi.su2;
    boundaryField : MARKER_SUPERSONIC_INLET=( inflow, 200, 57.4, 2000, 0, 0 );
                    MARKER_SUPERSONIC_OUTLET=( outflow );
                    MARKER_SYM= ( Symmetry )
    physics : LIB_PhysicsParametersFluid.SOLVER;
    
    -- output of SU2 are DENSITY, MOMENTUM, ENERGY, NU_TILDE (turbulence SA model), PRESSURE, TEMPERATURE, MACH,
    -- PRESSURE_COEFF, LAMINAR_VISCOSITY, SKIN_FRICTION, HEAT_FLUX, Y_PLUS, EDDY_VISCOSITY (outputs depend on the solver)
    solve heat_flux with {LIB_PhysicsParametersFluid, LIB_SolvingTechniqueFluid, LIB_NumericalSchemeFluid};
    return heat_flux;
}

couple coupleModels1 (Tin) {
  var qw; -- heat flux
  coupledSurface = CoupledSurfaces(fluid_outer, cylinder_inner);
  qw = FluidModel(Tin, coupledSurface);
  Tout = SolidModel (qw, coupledSurface);
  return Tout;
  }
