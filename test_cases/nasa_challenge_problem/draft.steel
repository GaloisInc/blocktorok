-- TODO Add units

-- import P = lib.conduction_condition;
-- import V = lib.fluid_flow;

config {
  step : 2;
  totalTime : 10;
  -- Tw = P.InitialSolidTemperature;
  -- Run: couple (ModelFluid, ModelSolid, Tw);
  }

model StructureModel {
  input : qw;
  output : Tw;
  -- Convention from the Zhang paper: Tw (YL)
  -- Convention from the toy problem #3: Ts (YL)
  technique : FEM;
  boundary : Neumann(qw);
  physics : HeatTransfer { 2};
  -- TODO arg to HeatTransfer should be 'P'
  -- physics : HeatTransfer {P};
  rhos = P.SolidDensity;
  ks = P.SolidThermalConductivity;
  cps = P.SolidSpecificHeat;
  var Tw;   -- solid temperature
  rhos*cps*∇Tw- ks*△Tw = qw;

  }

model FluidModel {
  input : Tw;
  output : qw;
  technique : FVM;
  boundary: Dirichlet (Tw);
  -- TODO change input to boundary conditions
  -- boundary: Dirichlet (P.InitialSolidTemperature);
  physics : FluidFlow {2};
  -- Why don't we put this in a library, just to be consistent with HeatTransfer
  -- TODO Add Fluid constructor
  -- physics : ModelType : FluidFlow {
  --   solver = compressibleFreeStreamDefinition,
  --   fluidModel = standardAir
  --   ViscosityModel =  sutherland
  --   thermalConductivityModel = constant_prandtl
  -- }


-- some of these are variables too!
-- listed here are the initial values that will get updated with time (mu)
  gamma = standardAir.ratio_Specific_Heat; -- a perfect gas
  mu = sutherland.viscosityRef; -- dynamic viscosity, depends on temperature!
  R =  standardAir.GasConstant; -- specific gas constant
  Pr = constant_prandtl.LaminarPrandtlNumber; -- Prandtl number

  -- variables we are solving for
  var u; -- velocity in x direction (U = [u, v, w])
  var v; --  velocity in y direction (U = [u, v, w])
  var w; -- velocity in z direction (U = [u, v, w])
  var e;  -- internal energy
  var rhof; -- fluid density
  var T; -- fluid temperature, depends on e
  var k; -- thermal conductivity, depends on mu
  var mu; -- dynamic viscosity, depends on T
  var P; -- pressure, depends on T
  var tau; -- viscous stress tensor

  -- Navier-Stokes and closure equations
  \frac{\partial \rho}{\partial t} + \div \rho \vec{U} = 0
  \frac{\partial \rho \vec{U}}{\partial t} + \div \rho \vec{U} \times \vec{U} + \div( \tau - PI) = 0
  \frac{\partial \rho e}{\partial t} + \div(\rho e + P)\vec{U} - \div \tau \vec{U} - \div k \grad T = 0
  \tau_{xy} = \tau_{yx} = \mu (\frac{\partial u}{\partial y} + \frac{\partial v}{\partial x})
  \tau_{xz} = \tau_{zx} = \mu (\frac{\partial u}{\partial z} + \frac{\partial w}{\partial x})
  \tau_{yz} = \tau_{yz} = \mu (\frac{\partial v}{\partial z} + \frac{\partial w}{\partial y})
  \tau_{xx} = \frac{2}{3} \mu (2\frac{\partial u}{\partial x} - \frac{\partial v}{\partial y} - \frac{\partial w}{\partial z})
  \tau_{yy} = \frac{2}{3} \mu (-\frac{\partial u}{\partial x} + 2\frac{\partial v}{\partial y} - \frac{\partial w}{\partial z})
  \tau_{zz} = \frac{2}{3} \mu (-\frac{\partial u}{\partial x} - \frac{\partial v}{\partial y} + 2\frac{\partial w}{\partial z})
  P = \rho R T
  e = \frac{R}{\gamma - 1}T
  e = \frac{P}{\gamma - 1} + \frac{1}{2} \sqrt{u^2 + v^2 + w^2}
  \mu = \mu_0 \frac{T_0 + C}{T + C}(\frac{T}{T_0})^\frac{3}{2}
  k = \frac{\gamma R \mu}{P_r (\gamma - 1)}
  }

couple StructureModel FluidModel {
  input : Tin;
  output : Tout;
  var qw; -- heat flux
  qw = FluidModel(Tin);
  Tout = ModelSolid (qw);
  -- TODO add zone interface
  }

-- def couple (m1, m2, Tin):
--  qw = m1 (Tin)
--  Tout = m2 (qw);
--  return Tout
